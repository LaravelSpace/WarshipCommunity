# 技术负债

## 技术负债的简介

技术负债（英语：Technical debt），又译技术债，也称为设计负债（design debt）、代码负债（code debt），是编程及软件工程中的一个比喻。指开发人员为了加速软件开发，在应该采用最佳方案时进行了妥协，改用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担。是由漫无计划的软件架构，或者匆忙的软件开发引起的后果。这种技术上的选择，就像一笔债务一样，虽然眼前看起来可以得到好处，但必须在未来偿还。软件工程师必须付出额外的时间和精力持续修复之前的妥协所造成的问题及副作用，或是进行重构，把架构改善为最佳实现方式。

技术债务是一个很早就被提出的概念，1992 年由 Ward Cunningham（wiki 创始人）提出。指技术团队在设计架构或者开发的过程中，基于短期的目标选择了一个方便实现的方案，从长远考虑，这种方案会带来长久的消极影响。技术债务和金融债务非常的类似，以至于在聊到这个话题时，都会用金融债务做比喻。

## 举个例子

这里引用网上的一个例子。

假设差评君想要搬运一堆石头，但是身为一个优雅的人，不愿意徒手去干这活儿。（ 放在软件开发里，往往是因为需求不适合人来做 ）于是叫了一帮开发弟兄们，来解决一下这个问题。小黑胖觉得可以做个推车，大家也认同这个方案，于是就这么定了。

![p01](.\images\technical-debt\p01.jpg)

于是，世超做轮子，小黑胖做车身，小二做纤绳。这个过程，和技术开发类似，大家分头做一个个功能，然后组合。让我们假设当时技术比较落后，没有办法生产比较圆的东西，或者说轮子在这之前都没被发明过，大家也不知道该做成圆的还是方的，就用方的轮子了。颠着颠着也还能用，于是就这么凑合着了。（例子里场景比较荒唐，但在早期技术开发的时候，确实有因为技术受限做不出完美方案的情况出现，只好给某个部分做妥协。也有可能是设计的时候没想到，或者是让项目尽快完成）

![p02](.\images\technical-debt\p02.jpg)

车子造好了，大家费了很大的劲，开始装石头进去。拖着拖着，发现这轮子不光会颠，碰到软的地面还会陷进去，总而言之用是能用，但是不好用。

![p03](.\images\technical-debt\p03.jpg)

这时候，负责开发轮子的世超拿着两个圆形的东西跑过来，说找到更好的轮子了！但是，装上轮子需要停下手头的活儿，并且还得拆装小车，这些事儿都要费很多功夫，更何况万一这新轮子的轴不搭还得重做呢。

在现实的技术开发中，这个所谓 “ 换轮子 ” 需要费的精力和金钱往往是很惊人的，因此很多时候会选择妥协地用着不太完美的方案。于是咱们决定继续用方轮子的方案。

![p04](.\images\technical-debt\p04.jpg)

但速度不快的确是个问题，于是决定给小车做一次升级：给它安个推进器。

![p05](.\images\technical-debt\p05.jpg)

但这么搞发现效果不太好，因为速度太快，方轮子磕地面会越发剧烈。这个本来很棒的升级方案，因为之前的一次妥协，变得不太好了。但好在能勉强解决，就是把推进器做成斜向上的，这样小车就会稍微往上弹起，轮子变得不太容易磕地面了。

现实中，一个技术产品需要往后迭代，增加功能时，有时候会受老功能里不太完美的代码的影响，为了解决它往往需要在做新功能时也妥协一部分。

![p06](.\images\technical-debt\p06.jpg)

然后，因为推进器的设计，又有新的问题出现了。因为这么移动时，需要稍稍的 “ 蹦 ” 起来一些，导致这个小车太晃了，于是咱又不得不给小车加个盖子防止石头掉出来。

![p07](.\images\technical-debt\p07.jpg)

这就不光是妥协的问题了，我们甚至需要做一些工作，专门去维护因为妥协而造成的问题。随后，因为盖子的问题，咱们得做扣子不让盖子乱跑，轮子老磕地面还容易坏，石头晃来晃去也让车子很不稳定，总而言之问题越来越多，补都补不过来。最后，咱们终于觉得换个轮子的重要性不可忽视了，但是这时候再看看，拆了重做的工作量更多了。

以上，大概就是欠下技术债的样子了。为什么要说它是债呢？因为真的很形象。

一开始，我们用方形轮子这种糟糕的设计时，就好像是欠下了一笔债。而一旦小车运行起来以后，要还债就得付出停车和修改的代价，这多付的地方就是利息了。再然后，当我们想要升级的时候，因为方轮子的关系，花了额外的时间精力去解决推进器适配问题，还做了妥协，这就好比是再欠一笔来填原来的利息。因为推进器也做了妥协，产生出了新的问题，利滚利了。

这时候终于忍不住想换轮子，想还债了，回头看看，发现债务和利息加起来变得非常恐怖。

在技术开发领域，这些利息可能是。本来添加个很简单的新功能，但是却花很大功夫来磨合原有的项目。一些怎么都搞不定的错误，甚至得专门花时间金钱来处理。而还债呢。当一个项目在原有基础上添了很多东西以后，你要 “ 还债 ” 几乎等于重做。这就好比你造大楼，地基打歪了，你再想修的话得把上面的建筑一起敲了再搞。这个时候，你说还吧，太昂贵了。

更麻烦的是，技术债有一点和贷款不一样，就是很多时候直到问题出现才能意识到自己欠了技术债，比如说设计失误。但是这不一定是个绝对要规避的东西，有时候，一个项目拖不到更好的方案时，需要贷这样一笔技术债来加速一下进程，尽快上线让它运转起来也是有必要的。在知情的情况下，要不要欠技术债，欠下以后怎么还，多久还，也是一个开发战略，做技术开发绝对不是蒙头写代码那么简单。

## 技术债的产生和解决方案

我发现一个很有意思的现象，开发团队都不太愿意接手别人已经开发好或者开发中的项目，而更愿意接一个从头开始开发的项目。其中一个很大的原因就是项目中隐藏的技术债务，担心是否有能力消化这些债务。

### 如何产生

技术债务来无影，我们你们他们人人“有份”。

毫无疑问作为一名有追求的工程师，没人愿意在项目中引入技术债务。但技术债务总是悄无声息的在积累。总结下来主要有下面的一些：

#### 设计和架构

项目初期的设计只为了满足当前的需要，没有更多一步的考虑。随着项目复杂度增加，问题越来越多的暴露出来。当你下定决心进行重构的时候，产品经理或者项目经理告诉你，这个礼拜必须上线。

#### 代码

在精益制造中，对库存有着严格的要求。精益强调减少库存，因为持有库存就意味着巨大成本。代码也一样，项目的代码越多，意味着添加一个新功能时付出的成本越多。

代码写好就提交，意味着欠债的开始。稍微欠点儿技术债的确可以加速开发速度，但前提是事后及时重写代码。如果只借不还，后果很危险。在不准确的代码上所花的每一分钟，都算是技术债的应付利息。不稳固、脆弱的代码实现所引发的债务负担，会使整个工程组织陷入裹足不前的艰难境地！

代码方面产生技术债的原因很多，例如：

- 如期完工的压力，比如每周 996 都开发不完的任务。
- 神秘数字、混乱的命名、不准守代码规范。
- 不合适的设计，比如过度设计、业务发现大变化、抽象能力不足等。
- 试图以错误的方式提高效率。
- 工程师在解决一个 BUG 的时候，并没有找到 BUG 产生的根本原因，只是短视的规避。
- 试图减少测试提高效率，比如单元测试、集成测试、系统测试、白盒测试、黑盒测试不足。
- 初级工程师由于缺乏经验编写了低质量的代码也会导致代码债务的增加。
- 新人无法理解旧人所写代码，代码缺少传递性。

#### 测试

- 手工测试过多。
- 测试用例覆盖不够，导致一些本该解决的问题被隐藏。
- 没有完整的自动化测试流程，仅靠人工测试。
- 业务代码变化快，测试的用例修改不及时。

#### 项目工期压力

研发人员工作压力大，一方面需要不断的开发新的需求，另外一方面又需要维护前期遗漏的代码。研发人员就在开发，修复，加班，开发，修复，加班的循环当中，苦不堪言。

### 技术债的后果

- 交付时间延长
- 开发和支持成本持续上升
- 可预测性较低
- 缺陷数量可观
- 爆发点不可逾期

### 如何还债

#### 好的设计和架构

作为架构人员一定要对项目当下需求以及未来的需求能够做一个预见，避免随着项目复杂度提升导致后期重构的风险。选择合适的技术而不是最好的技术。遵从一些设计最基本的原则：模块化，轻耦合，无状态。模块可单独交付也可组合交付。

#### Code Review

Code Review 很重要，千万不要以时间或者其他原因放弃 Code Review。Code Review 工作可以在开始就将可能产生的债务清理掉。如果你能全款，为什么要选择贷款呢？

#### 质量保证

对从自己指尖敲下的每段代码负责，对编码的规范的严格执行，对代码效率的极致追求，对每个BUG追根溯源。这些都会在不知不觉的过程中减少技术债务的产生。

#### 严格测试

增加自动化测试覆盖率，通过自动化测试覆盖住流程，减少漏测的几率，并为后期偿还债务时可能需要的重构提供保障。无情的测试：越是仔细，全面的测试，越是有助于系统的健壮。

#### 定期的技术债务偿还

和项目经理或者产品经理协商一个迭代或者趁迭代的空隙，专门用于解决前期积累的技术债务。应用有债就还原则，将积累的技术债务按照优先级就行排序，将最需要解决的债务分配一些到迭代之中。分期偿还技术债，先偿还高息技术债。一方面可以清理债务，另一方面可以是开发人员得到一定程度的放松。提前偿还，相当于等额本金。

## 代码整洁之道

Bob大叔在其著作《代码整洁之道》的前言中引用了这样一幅漫画：

![p08](.\images\technical-debt\p08.jfif)

使用漫画中的“每分钟爆粗数量”来衡量代码质量是个很有趣的玩笑，强调了代码的可读易懂等这样的“内在”质量属性。相对于满足需求规范这样的“外在”质量属性，“内在”的代码质量属性强调的是支持实现功能需求的代码内部结构的质量。《Sonar code quality testing essential》一书中从七个维度定义了代码的这种内在质量，Sonar开发团队上纲上线的戏称为开发人员七宗罪：

- 编码规范：是否遵守了编码规范，遵循了最佳实践。
- 潜在的BUG：可能在最坏情况下出现问题的代码，以及存在安全漏洞的代码。
- 文档和注释：过少（缺少必要信息）、过多（没有信息量）、过时的文档或注释。
- 重复代码：违反了 Don’tRepeat Yourself 原则。
- 复杂度：代码结构太复杂（如圈复杂度高），难以理解、测试和维护。
- 测试覆盖率：编写单元测试，特别是针对复杂代码的测试覆盖是否足够。
- 设计与架构：是否高内聚、低耦合，依赖最少。

## 参考

- [技术负债](https://baike.baidu.com/item/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA/17587713?fr=aladdin)
- [代码质量与规范，那些年你欠下的技术债](https://www.cnblogs.com/qcloud1001/p/9257269.html)
- [老程序员欠下技术债跑了，新来的不断还债能把公司耗死！](http://baijiahao.baidu.com/s?id=1599160912769877274&wfr=spider&for=pc)
- [如何处理技术债](https://www.jianshu.com/p/e532a7e4f768)
- [警惕呀，那深不见底的技术债！](https://www.sohu.com/a/167963698_720560)